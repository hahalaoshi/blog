---
title: ARM体系结构基本知识
date: 2020-05-05 17:11:34
tags:
  - armv7
typora-root-url: ../../source
---

# 计算机体系结构

## 冯·诺依曼架构

 ![image-20200511020504995](/images/arm-abc/image-20200511020504995.png)



## 哈佛架构

 ![image-20200511020655435](/images/arm-abc/image-20200511020655435.png)



## 混合结构

 ![image-20200511020800532](/images/arm-abc/image-20200511020800532.png)



# 总线与地址

## 概念

 ![image-20200511021129887](/images/arm-abc/image-20200511021129887.png)



## 编址

 ![image-20200511021335266](/images/arm-abc/image-20200511021335266.png)



```shell
root@xmalloc:/proc/self# cat /proc/iomem
00000000-00000fff : Reserved
00001000-0009fbff : System RAM
0009fc00-0009ffff : Reserved
000a0000-000bffff : PCI Bus 0000:00
000c0000-000c95ff : Video ROM
000c9800-000ca5ff : Adapter ROM
000ca800-000ccbff : Adapter ROM
000f0000-000fffff : Reserved
  000f0000-000fffff : System ROM
00100000-7ff7ffff : System RAM
  6fc00000-708031d0 : Kernel code
  708031d1-7126c5ff : Kernel data
  714eb000-7173ffff : Kernel bss
7ff80000-7fffffff : Reserved
80000000-febfffff : PCI Bus 0000:00
```

Linux上可以通过 `cat /proc/iomem` 来查看地址分配。



# 指令集、微架构与编译器



# ARM体系结构及指令

 ![image-20200521004525465](/images/arm-abc/image-20200521004525465.png)



**Tips:**

1. RISC是固定指令长度的，都是单周期指令，但是arm不是，arm并不是所有指令都是单周期的
2. Thumb指令集是16位的



# Arm工作模式

| 处理器模式      | 模式编号 | 简介                                                   |
| --------------- | -------- | ------------------------------------------------------ |
| User mode       | 0b10000  | 处理器正常运行时的工作模式                             |
| FIQ mode        | 0b10001  | 快速中断模式，中断优先级比IRQ高                        |
| IRQ mode        | 0b10010  | 中断模式                                               |
| Supervisor mode | 0b10011  | 管理模式，操作系统保护模式，复位和软中断时会进入此模式 |
| Abort mode      | 0b10111  | 数据存取异常，指令读取拒绝会进入该模式                 |
| Undefined mode  | 0b11011  | 未定义指令被执行，CPU进入未定义模式                    |
| System mode     | 0b11111  | 类似用户模式，但可以运行特权级OS任务：如切换到其它模式 |
| Monitor mode    | 0b10110  | 仅限于安全扩展                                         |



# 寄存器

## 各类寄存器详细介绍

 ![image-20200521011416016](/images/arm-abc/image-20200521011416016.png)

**Tips:**

1. 各种模式下都有自己独立的寄存器，例如在FIQ模式下，有自己额外的R8-R12寄存器
2. 每个模式下都有一个SPSR寄存器用来保存CPSR的工作状态

 ![image-20200521011726820](/images/arm-abc/image-20200521011726820.png)



## 状态寄存器

 ![image-20200521012057270](/images/arm-abc/image-20200521012057270.png)

**Tips:**

CPSR寄存器位0~位5组合在一起可以确定工作模式

# ARM寻址方式

## 类别

- 寄存器寻址

- 立即寻址
- 寄存器偏移寻址
- 寄存器间接寻址
- 基址寻址
- 多寄存器寻址
- 堆栈寻址
- 相对寻址

## 详细介绍

### 寄存器寻址

```asm
#将R2寄存器的值存入R1
MOV R1, R2;
#将R1-R2的值保存到R0
SUB R0, R1, R2;
```

### 立即寻址

```asm
#将R0寄存器的值减去常数1
SUBS R0, R0, #1;
#将常数0xff00放入R0寄存器
MOV R0, #0xff00;
```

### 寄存器偏移寻址

```asm
#R2左移3位->R0
MOV R0, R2, LSL, #3;
```

常用移位操作：

- LSL：逻辑左移
- LSR：逻辑右移
- ASR/ASL：算术右移/左移
- ROR/ROL：循环右移/左移
- RRX：带扩展的循环右移  CPSR寄存器中的进位来填充最高位的符号

### 寄存器间接寻址

寄存器为操作数的地址指针

​	----寄存器中的值是一个地址，先读取该地址，然后去该地址读取真正的值

```asm
#将R2中的值作为内存地址，取出该地址中的数据送到R1
LDR R1, [R2]
#将R2中的值作为内存地址，取出此地址中的数值与R1进行交换
SWP R1, R1, [R2]
```

可以举一个c语言指针的例子

 ![image-20200521013509841](/images/arm-abc/image-20200521013509841.png)

 ![image-20200521013635635](/images/arm-abc/image-20200521013635635.png)

### 基址寻址

寄存器中的值与给出的偏移量相加得到地址

取出此地址中的值

应用：查表，数组操作，功能部件寄存器的访问

```asm
#先将R0中的值减2作为内存地址，再把R1的值写到此地址
STR R1, [R0, #-2]
#先将R0中的值作为内存地址，把R1中的值写到此地址，然后R0加2
STR R1, [R0], #2
#将R3中的数值加0x03作为内存地址，取出此地址中的值赋值给R2
LDR R2, [R3, #0x03]
```



### 多寄存器寻址

```asm
#将R1内存地址单元中的数据读出到R2-R7, R1自动加1
LDMIA R1!, {R2-R7, R12}
#将R3-R6, R10中的数据保存到R0指向地址, R0自动加1
STMIA R0!, {R3-R6, R10}
```

**Tips:**

 ![image-20200521014134644](/images/arm-abc/image-20200521014134644.png)

### 堆栈寻址

```asm
#将R1-R7,LR入栈
STMFD SP!,{R1-R7,LR}
#数据弹出，弹出到R1-R7,LR
LDMFD SP!,{R1-R7,LR}
```

ARM中栈的操作：

- 子程序局部变量存储、参数传递要通过堆栈完成
- arm指令集中没有出栈和入栈的专门指令
- arm中栈的操作是通过 `stm/ldm` 和栈指针 `sp` 配合操作完成
- arm采用栈的类型是满递减堆栈

栈的分类：

​	递增堆栈：向上生长，向高地址方向增长

​	递减堆栈：向下生长，向低地址方向增长

​	满堆栈 F：SP栈指针指向栈顶元素

​	空堆栈 E：SP栈指针指向下一次要入栈元素的地址

思考：arm采用满递减堆栈有什么好处？



### 相对寻址

由PC作为基址，指令中的地址码段作为偏移量

常见指令：B、BL、adr

B的前后跳转范围[0, 32M]

 ![image-20200521020138092](/images/arm-abc/image-20200521020138092.png)



# ARM汇编指令

## 指令格式

![arm-op](/images/arm-abc/arm-op.png)

## 指令

### 存储器访问指令

  arm是RISC结构，无法直接对存储数据直接进行操作，要首先加载到寄存器才能处理。对存储器访问使用 `LDR` 和 `STR` 实现。

基本命令：

```asm
#将R0值作为内存地址，取出该地址值保存到R1
LDR R1, [R0]
#将R1的值保存到以R0中的值为地址的存储单元
STR R1, [R0]
#读取1字节
LDRB/STRB
#实现一组寄存器和连续内存单元之间传输数据
LDM/STM
#将R1与R0指向的存储单元内容进行交换
SWP R1, R1, [R0]
#将[R0]读取到R1,将R2写入到[R0]存储单元
SWP R1, R2, [R0]
```

### 数据传送指令

```asm
#将立即数1传送到寄存器R1中
MOV R1, #1;
#将R0中的值传送到R1寄存器中
MOV R1, R0;
#子程序返回
MOV PC, LR;
#将0xFF取反后赋值给R1
MVN R1, #0xFF
```

### 算术逻辑运算指令

加减&与或非&异或&清除&乘法

```asm
ADD R1, R1, #1;					R1=R1+1
ADC R1, R1, #1;					R1=R1+1+C (CPSR中的C标志位)
SUB R1, R1, R2;					R1=R1-R2
SBC R1, R1, R2;					R1=R1-R2-C
AND R0, R0, #3;					保留R0的bit0和1,其余位清除
ORR R0, R0, #3;					置位R0的bit0和bit1
EOR R0, R0, #3;					反转R0中的bit0和bit1
BIC R0, R0, #3;					清除R0中的bit0和bit1
MUL R2, R1, R0;					R2=R1*R0
MLA R3, R2, R1, R0;			R3=R2*R1+R0
```

### 比较指令

比较指令会影响CPSR寄存器的N、Z、C、V

```asm
CMP R1,#10;		R1-10,结果影响N、Z、C、V位
CMP R1, R2;		R1-R2,结果影响N、Z、C、V位
CMN R0, #1;		R0-(-1), 比较取负的值，负数比较
TST R1, #1;   R1&1	位测试
TEQ R1, R0;		R1^R0 测试位相等
```

### 条件执行

 ![image-20200522012048994](/images/arm-abc/image-20200522012048994.png)

示例：

 ![image-20200522012534371](/images/arm-abc/image-20200522012534371.png)

### 跳转指令

 ![image-20200522013022745](/images/arm-abc/image-20200522013022745.png)

### 伪指令

伪指令并不是ARM指令集中的指令，编译时会将这些伪指令等效为一条或多条机器指令

 ![image-20200522013334352](/images/arm-abc/image-20200522013334352.png)

#### LDR伪指令

##### 作用

大范围的地址读取，[0,4G]，常用来加载外部设备

##### 指令格式

```asm
LDR R0,=立即数 
or 
LDR R0,=标号
```



##### 问题

LDR、MOV和LDR伪指令的区别？

LDR指令通常用于寄存器间接寻址:

```asm
#将R1值作为内存地址，取该内存地址内容放入R0
LDR R0,[R1];
#将标号LOOP代表的内存地址处的内容放入R0
LDR R0, LOOP;
```

MOV指令通常用于寄存器间传输数据：

```asm
#将寄存器R1的值放入R0
MOV R0, R1;
#将立即数20放入R0
MOV R0, #20;
```

LDR伪指令通常用来加载一个32位立即数或地址到指定寄存器：

```asm
#常数0x30008000放入R0
LDR R0, =0x30008000
#标号LOOP所代表的内存地址放入R0
LDR R0, =loop
```

##### 思考

为什么不能LDR R0, 0x30008000? 为什么有了MOV和LDR指令，还要使用LDR伪指令？

如果有MOV和LDR指令，LDR伪指令可以表示成下面这样：

```asm
MOV R0,#30008000
LDR R1,[R0]
```

但是，实际上ARM指令通常是32位=操作数+操作码，

![image-20200522210156100](/images/arm-abc/image-20200522210156100.png)

而如果操作数是一个32位的值，这样子会超过操作数的表示大小，是无法被指令编码的。

LDR伪指令实际上是多条指令的组合，如果立即数小于8bit数值范围时，LDR伪指令被转换成下面的指令：

```asm
LDR R0,=200
等价于
MOV R0,#200
```

超过32位大小时，转换为LDR指令+文字池的形式

```asm
LDR R0,=0x3008000
等价于
LDR R0,[PC,#offset]
...
DCD 0x3008000
```



#### ADR伪指令

##### 作用

小范围的地址读取，将基于PC相对偏移的地址值读取到寄存器中

相对寻址，做到代码位置无关

##### 示例

```asm
ADR R0, __start

...

_start
		b _start
```

相对寻址，ADR伪指令当前地址 + 标号_start与ADR伪指令的偏移，其中：

ADR当前指令地址：（PC - 8）

偏移量：offset= _start - (PC - 8)

所以该条指令可以表示成下面的指令形式：

```asm
ADD R0, PC, #offset
```

##### 问题

LDR和ADR有什么区别？

这两个伪指令都是用来加载一个地址到指定寄存器

|          | LDR            | ADR                                              |
| -------- | -------------- | ------------------------------------------------ |
| 用途     | 操作外设寄存器 | 相对寻址，生成位置无关代码                       |
| 实现     | 绝对地址       | 相对地址                                         |
| 地址范围 | [0,4G]         | 标号在同一段中，地址对齐[0,1020]，未对齐[0,4096] |

## 汇编程序

### 格式

 ![image-20200522213705754](/images/arm-abc/image-20200522213705754.png)

### 示例

 ![image-20200522213743226](/images/arm-abc/image-20200522213743226.png)

### 符号与标号

#### 定义

 ![image-20200522214006054](/images/arm-abc/image-20200522214006054.png)

 ![image-20200522214025026](/images/arm-abc/image-20200522214025026.png)

#### 局部标号

 ![image-20200522214637669](/images/arm-abc/image-20200522214637669.png)

##### 示例

 ![image-20200522214708139](/images/arm-abc/image-20200522214708139.png)

##### 应用

linux内核调试函数printsacii实现

在arch/arm/kernel/debug.S查看该函数中局部符号的使用



## 伪操作

